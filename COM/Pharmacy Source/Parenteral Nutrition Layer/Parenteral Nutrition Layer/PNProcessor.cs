//===========================================================================
//
//					            PNProcessor.cs
//
//  This class holds all business logic for Parenteral Nutrition.
//
//  Mainly deals with calculations for View and Adjust screen
//
//  There are a number of caching methods for the processor SaveToCache, GetFromCache, 
//  these store\retrieve the processor from the cache. However despite having a 5day expiry, 
//  and marking them as non removable the web server can still remove them!!! 
//  At some point might need to remove at least one method (either 1, or 2)
//  Three methods were implemented to counter act this 
//      1. If server removes a processor if will call RemovedFromCacheCallback which 
//         will reinsert it into the cache.
//      2. There is static member variable cachedProcessors that also 
//         stores the processor.
//      3. The data is also cached to the web page via WriteXml
//  Hopefully one of these methods will manage to hang on to the cached data.
//
//  Note when adding new members or properties to this class it has a Clone, 
//  WriteXML, and ReadXML, that may need to be updated.
//  
//  Usage:
//  PNProcessor processor = new PNProcessor(jsonRegimenString, 56.0)
//  processor.UpdateItem('INTI110', 23.0);
//  processor.ToJsonString(true, true, false);
//
//	Modification History:
//	15Nov11 XN  Written
//  20Apr12 XN  TFS32337 Removed startup check for volume to product rule as 
//                       volume is handled differently
//  20Apr12 XN  TFS32363 Added Validation rule to check for duplicate ingredient to product rules
//  23May12 XN  In CreateRow convered ' to &#149; for product description 
//              to prevent script error
//  20Nov12 XN  Updated CreateRow to disable of select in non-editable fields (32007)
//  05Dec12 XN  29763 Show PO4 tooltip on total line if nothing is there
//  21Mar13 XN  added method ValidateProductLimits
//  03Apr13 XM  added methods WriteXml, and ReadXml
//===========================================================================
using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Xml;
using _Shared;
using ascribe.pharmacy.businesslayer;
using ascribe.pharmacy.icwdatalayer;
using ascribe.pharmacy.shared;
using Newtonsoft.Json;

namespace ascribe.pharmacy.parenteralnutritionlayer
{
    /// <summary>Holds business logic for Parenteral Nutrition (mainly calculations for View and Adjust screen)</summary>
    public class PNProcessor : ICloneable
    {
        #region Data Types
        /// <summary>Used to cache a PN processor with expiry date (as failsafe to web cache)</summary>
        private struct CachedProcessor
        {
            public DateTime    ExpiryDate;
            public PNProcessor Processor;

            public CachedProcessor(DateTime expiryDate, PNProcessor processor)
            {
                this.ExpiryDate = expiryDate;
                this.Processor  = processor;
            }
        }
        #endregion

        #region Member Variables
        /// <summary>Details of products in the regimen</summary>
        private List<PNRegimenItem> regimenItems;

        /// <summary>List of items deleted from regimen</summary>
        private List<string> deletedItems;

        /// <summary>dosing weight of patient</summary>
        private double dosingWeightInml; 

        /// <summary>Mapping of ingredient to PN Code</summary>
        private Dictionary<string, string> ingredientToPNCode;

        /// <summary>Real belt and braces to store the cached processor as static variable</summary>
        private static Dictionary<string, CachedProcessor> cachedProcessors = new Dictionary<string,CachedProcessor>();

        /// <summary>List of dupbliate ingredient rulest generated by call to method GetIngredientToProductViloation TFS32363</summary>
        private List<string> duplicateIngredientRuleViolations = new List<string>();
        #endregion

        #region Public Properties
        /// <summary>Patient the regimen is for</summary>
        public PatientRow Patient { get; private set; }

        /// <summary>Episode the regimen is for</summary>
        public EpisodeRow Episode { get; private set; }

        /// <summary>Prescriptino the regimen is for</summary>
        public PNPrescriptionRow Prescription { get; private set; }

        /// <summary>Regimen saved with this processor</summary>
        public PNRegimen Regimens { get; private set; }

        /// <summary>Regimen item saved with this processor</summary>
        public PNRegimenRow Regimen { get { return Regimens[0]; } }

        /// <summary>Details of products in regimen</summary>
        public IEnumerable<PNRegimenItem> RegimenItems { get { return regimenItems; } }

        // Important product codes
        public string NaClPNCode        { get { return ingredientToPNCode[PNIngCode.NaCl]; } }
        public string KClPNCode         { get { return ingredientToPNCode[PNIngCode.KCl ]; } }
        public string DiluentPNCode     { get { return ingredientToPNCode[PNIngCode.Dil ]; } }
        public string KPO4PNCode        { get { return ingredientToPNCode[PNIngCode.KPO4]; } }

        /// <summary>kcal per gram of fat (read from WConfiguraion cached here ease of use)</summary>
        public double kcalPerGramFat    { get; private set; }

        /// <summary>kcal per gram of glucose (read from WConfiguraion cached here ease of use)</summary>
        public double kcalPerGramGlucose{ get; private set; }

        /// <summary>Ask to adjusting sodium levels</summary>
        public bool AskAdjustNa { get; private set; }

        /// <summary>Ask to adjusting potassium levels</summary>
        public bool AskAdjustK { get; private set; }

        #endregion

        /// <summary>Constructor</summary>
        public PNProcessor()
        {
            this.regimenItems       = null;
            this.deletedItems       = new List<string>();
            this.dosingWeightInml   = 0.0;
            this.Patient            = null;
            this.Episode            = null;
            this.Prescription       = null;
            this.Regimens           = null;
            this.ingredientToPNCode = null;
            this.AskAdjustK         = true;
            this.AskAdjustNa        = true;
        }

        public void Initalise(PNRegimen regimens, IEnumerable<PNRegimenItem> regimenItems)
        {
            this.Regimens     = regimens;
            this.regimenItems = regimenItems.ToList();

            // Prescription
            PNPrescrtiption prescriptions = new PNPrescrtiption();
            prescriptions.LoadByRequestID(this.Regimen.RequestID_Parent);
            if (!prescriptions.Any())
                throw new ApplicationException(string.Format("Invalid prescription request ID {0}", this.Regimen.RequestID_Parent));
            this.Prescription = prescriptions[0];

            // Load the episode
            Episode episode = new Episode();
            episode.LoadByEpisodeID(prescriptions[0].EpisodeID);
            this.Episode = episode[0];

            // Load the patient
            ascribe.pharmacy.icwdatalayer.Patient patients = new ascribe.pharmacy.icwdatalayer.Patient();
            patients.LoadByEntityID(this.Episode.EntityID);
            this.Patient = patients[0];

            // Get regimen minor details
            this.deletedItems.Clear();
            this.dosingWeightInml   = this.Prescription.DosingWeightInkg; 
            this.kcalPerGramFat     = PNSettings.Constants.GetkcalPerGramFat();
            this.kcalPerGramGlucose = PNSettings.Constants.GetkcalPerGramGlucose();

            // Get the ingredient PNCode values
            if (this.ingredientToPNCode == null)
                ingredientToPNCode = this.GetProductToIngredientAllocation();

            // Ask to adjust sodium and potassium
            this.AskAdjustK  = PNSettings.ViewAndAdjust.GetAdjustK (Prescription.AgeRage);
            this.AskAdjustNa = PNSettings.ViewAndAdjust.GetAdjustNa(Prescription.AgeRage);
        }

        /// <summary>Clears the edit flag on all products</summary>
        public void ClearEditFlag()
        {
            this.regimenItems.ForEach(i => i.Edited = false);
        }

        /// <summary>Replace all existing items, with specified list</summary>
        public void Set(List<PNRegimenItem> items)
        {
            // Add insert existing items
            items.ForEach(i => this.UpdateItem(i.PNCode, i.VolumneInml));

            // Remove items that are not in the standard regimen
            List<PNRegimenItem> itemsToRemove = this.RegimenItems.Where(i => items.FindByPNCode(i.PNCode) == null).ToList();
            itemsToRemove.ForEach(i => this.RemoveItem(i.PNCode));
        }

        /// <summary>Update existing PN product, or add a new one</summary>
        /// <param name="PNCode">PN product code</param>
        /// <param name="volumeInml">product volume in ml</param>
        public void UpdateItem(string PNCode, double volumeInml)
        {
            PNRegimenItem item = RegimenItems.FindByPNCode(PNCode);

            if (item == null)
            {
                if (!volumeInml.IsZero())
                {
                    // Add product to regimem list (to calculate new totals)
                    item = new PNRegimenItem(PNCode, volumeInml);
                    item.Edited = true;
                    regimenItems.Add(item);
                }
            }
            else
            {
                if (volumeInml.IsZero())
                    RemoveItem(PNCode); // Delete existing item
                else
                {
                    // Update existing item
                    item.VolumneInml = volumeInml;
                    item.Edited = true;
                }
            }
        }

        /// <summary>Removes item from regimen</summary>
        public void RemoveItem(string PNCode)
        {
            // Remove item from the regimen list
            PNRegimenItem item = RegimenItems.FindByPNCode(PNCode);
            if (item != null)
                this.regimenItems.Remove(item);

            // Add item to the deleted list
            this.deletedItems.Add(PNCode);
        }

        /// <summary>
        /// Returns regimen as a json string, with full ingredient info for display in view and adjust screen
        /// {
        ///     "Remove":["INTI110"],
        ///     "Rows":["<tr PNCode=\\"VAMI090\\" SortIndex=\\"100\\" RowType=\\"product\\" VolumeInml=\\"23.4\\" Phosphate_mmol=\\"0.00\\" PhosphateInorganic_mmol=\\"0.00\\" PhosphateOrganic_mmol=\\"0.00\\" ><td><span id=\\"Edited\\">&#149;</span>Vamin 9</td><td><input type=\\"text\\" value=\\"23.4\\"  /></td>...<td><input type=\\"text\\" value=\\"0.42\\"  /></td></tr >",
        ///             "<tr PNCode=\\"TotalInml\\" SortIndex=\\"99999996\\" RowType=\\"total\\" VolumeInml=\\"23.4\\" Phosphate_mmol=\\"0.00\\" PhosphateInorganic_mmol=\\"0.00\\" PhosphateOrganic_mmol=\\"0.00\\" ><td style=\\"padding-left: 50px;\\">Total</td><td><input type=\\"text\\" value=\\"23.4\\"  /></td>...<td><input type=\\"text\\" value=\\"0.42\\"  /></td></tr >",
        ///             "<tr PNCode=\\"TotalInmlPerkg\\" SortIndex=\\"99999997\\" RowType=\\"total\\" VolumeInml=\\"23.4\\" Phosphate_mmol=\\"0.00\\" PhosphateInorganic_mmol=\\"0.00\\" PhosphateOrganic_mmol=\\"0.00\\" ><td style=\\"padding-left: 50px;\\">Total/kg</td><td><input type=\\"text\\" value=\\"0.42\\"  /></td>...<td><input type=\\"text\\" value=\\"0.42\\"  /></td></tr >"]
        /// }
        /// 
        /// Remove are the PNCode of items to be removed from the view and adjust screen
        /// Rows is and array of strings for row data in view and adjust screen that need to be updated, or added
        /// </summary>
        /// <param name="escapeQuotes">If json string should escape quote marks</param>
        /// <param name="forceSendAll">Force sending all items not just the edited ones</param>
        /// <param name="isReadonly">If grid is read only</param>
        /// <param name="includePrescription">If the prescription line is to be included</param>
        /// <returns>Regimen view and adjust data as a string</returns>
        public string ToJSONString(bool escapeQuotes, bool forceSendAll)
        {
            return ToJSONString(escapeQuotes, forceSendAll, false, false);
        }
        public string ToJSONString(bool escapeQuotes, bool forceSendAll, bool isReadonly, bool includePrescription)
        {
            // Get list of ingredients to display
            PNIngredient ingredient = PNIngredient.GetInstance();
            IEnumerable<string> ingredientDBNames  = ingredient.FindByForViewAdjust().OrderBySortIndex().Select(i => i.DBName).ToList();
            IEnumerable<string> po4DBNames         = ingredient.FindByPO4().Select(i => i.DBName).ToList();
            double dosingWeightInkg = this.Prescription.DosingWeightInkg;
            string row;

            using (TextWriter writer = new StringWriter())
            {
                using (JsonTextWriter jsonWriter = new JsonTextWriter(writer))
                {
                    jsonWriter.WriteStartObject();

                    // Add array of items to remove from view and adjust screen
                    jsonWriter.WritePropertyName("Remove");
                    jsonWriter.WriteStartArray();
                    foreach (string item in this.deletedItems)
                        jsonWriter.WriteValue(item);
                    jsonWriter.WriteEndArray();
                    this.deletedItems.Clear();

                    // Add array of rows to update in the view and adjust screen
                    jsonWriter.WritePropertyName("Rows");
                    jsonWriter.WriteStartArray();
                    foreach (PNRegimenItem item in this.RegimenItems.Where(r => forceSendAll || r.Edited))
                    {
                        PNProductRow product = item.GetProduct();

                        List<double?> ingValues = product.CalculateIngredientValues(ingredientDBNames, item.VolumneInml).Cast<double?>().ToList();
                        List<double>  po4Values = product.CalculateIngredientValues(po4DBNames,        item.VolumneInml).ToList();
                        double        totalPerKg= item.VolumneInml / dosingWeightInml;
                        bool isLipid = (product.AqueousOrLipid == PNProductType.Lipid);

                        row = CreateRow(item.PNCode, item.VolumneInml, item.Edited, "product", product.Description, product.SortIndex, ingValues, po4Values, po4DBNames, totalPerKg, !this.Regimen.IsCombined && isLipid, isReadonly);
                        if (escapeQuotes)
                            row = row.Replace("\"", "\\\"");

                        jsonWriter.WriteValue(row);
                    }

                    // Calculate the totals
                    List<double?> totals    = CalculateTotals(ingredientDBNames).Cast<double?>().ToList();
                    List<double>  po4Totals = CalculateTotals(po4DBNames       ).ToList();

                    double totalVolumInml          = this.RegimenItems.Sum(i => i.VolumneInml);
                    double totalVolumInmlPerKg     = (totalVolumInml / dosingWeightInml).To3SigFigish();

                    // Add the totals to the list of row to update 
                    // total rows still have a PNCode, and very high sort index, so are placed at end
                    row = CreateRow("TotalInml", totalVolumInml.To3SigFigish(), false, "total", "Total", 99999994, totals, po4Totals, po4DBNames, totalVolumInmlPerKg, false, true);
                    if (escapeQuotes)
                        row = row.Replace("\"", "\\\"");
                    jsonWriter.WriteValue(row);

                    List<double?> totalsPerKg   = totals.Select(t => (t / this.dosingWeightInml).To3SigFigish()).Cast<double?>().ToList();
                    List<double> po4TotalsPerKg = po4Totals.Select(t => (t / this.dosingWeightInml).To3SigFigish()).ToList();
                    row = CreateRow("TotalInmlPerkg", totalVolumInml.To3SigFigish(), false, "total", "Total/kg", 99999995, totalsPerKg, po4TotalsPerKg, po4DBNames, totalVolumInmlPerKg, false, true);
                    if (escapeQuotes)
                        row = row.Replace("\"", "\\\"");
                    jsonWriter.WriteValue(row);

                    // Add prescription rows
                    if (includePrescription)
                    {
                        // Add regimen row
                        DataColumnCollection columns = this.Regimen.RawRow.Table.Columns;
                        List<double?> regimenValues = new List<double?>();
                        foreach (string ing in ingredientDBNames)
                        {
                            if (columns.Contains(ing))
                                regimenValues.Add(this.Regimen.GetIngredient(ing) ?? double.NaN);       // TFS29385 2Apr12 XN Display empty requirements and prescription ing as empty fields on view and adjust
                            else
                                regimenValues.Add(null);
                        }

                        row = CreateRow("RequirementTotal", this.Regimen.VolumeInml.To3SigFigish(), false, "requirements", "Requirements Total", 99999996, regimenValues, new List<double>(), new List<string>(), null, false, true);
                        if (escapeQuotes)
                            row = row.Replace("\"", "\\\"");
                        jsonWriter.WriteValue(row);

                        IEnumerable<double?> regimenValuesPerKg = regimenValues.Select(v => v.HasValue ? v.Value / dosingWeightInkg : (double?)null);
                        row = CreateRow("RegimenTotalPerKg", this.Regimen.VolumeInml.To3SigFigish(), false, "requirements", "Requirements /kg", 99999997, regimenValuesPerKg, new List<double>(), new List<string>(), null, false, true);
                        if (escapeQuotes)
                            row = row.Replace("\"", "\\\"");
                        jsonWriter.WriteValue(row);

                        // Add prescription row
                        columns = this.Prescription.RawRow.Table.Columns;
                        List<double?> prescirpiontValues = new List<double?>();
                        foreach (string ing in ingredientDBNames)
                        {
                            if (columns.Contains(ing))
                                prescirpiontValues.Add(this.Prescription.GetIngredient(ing) ?? double.NaN); // TFS29385 2Apr12 XN Display empty requirements and prescription ing as empty fields on view and adjust
                            else
                                prescirpiontValues.Add(null);
                        }

                        row = CreateRow("PrescipriontTotal", this.Prescription.VolumeInml.To3SigFigish(), false, "prescription", "Prescription Total", 99999998, prescirpiontValues, new List<double>(), new List<string>(), null, false, true);
                        if (escapeQuotes)
                            row = row.Replace("\"", "\\\"");
                        jsonWriter.WriteValue(row);

                        IEnumerable<double?> prescirpiontValuesPerKg = prescirpiontValues.Select(v => v.HasValue ? v.Value / dosingWeightInkg : (double?)null);
                        row = CreateRow("PrescipriontTotalPerKg", this.Prescription.VolumeInml.To3SigFigish(), false, "prescription", "Prescription /kg", 99999999, prescirpiontValuesPerKg, new List<double>(), new List<string>(), null, false, true);
                        if (escapeQuotes)
                            row = row.Replace("\"", "\\\"");
                        jsonWriter.WriteValue(row);
                    }

                    jsonWriter.WriteEndArray();

                    // Add array of overage and volumes in the view and adjust screen
                    jsonWriter.WritePropertyName("OverageAndVolume");
                    jsonWriter.WriteStartObject();

                    jsonWriter.WritePropertyName("Supply48Hrs");
                    jsonWriter.WriteValue(this.Regimen.Supply48Hours);

                    double aqueousOrCombinedTotalVolume = this.RegimenItems.FindByAqueousOrLipid(!this.Regimen.IsCombined ? PNProductType.Aqueous : PNProductType.Combined).CalculateTotal(PNIngDBNames.Volume);
                    double lipidTotalVolume             = this.RegimenItems.FindByAqueousOrLipid(PNProductType.Lipid).CalculateTotal(PNIngDBNames.Volume);
                    
                    aqueousOrCombinedTotalVolume*= this.Regimen.SupplyMultiplier;
                    lipidTotalVolume *= this.Regimen.SupplyMultiplier;

                    jsonWriter.WritePropertyName("Data");
                    jsonWriter.WriteStartArray();
                    foreach (PNRegimenItem item in this.RegimenItems)
                    {
                        PNProductRow product = item.GetProduct();
                        double totalVolToUse = (!this.Regimen.IsCombined && product.AqueousOrLipid == PNProductType.Lipid) ? lipidTotalVolume : aqueousOrCombinedTotalVolume;
                        double overage = this.CalculateProductOverage(item.PNCode, totalVolToUse);
                        double volWithOverage = item.VolumneInml+ overage;
                        jsonWriter.WriteStartObject();

                        jsonWriter.WritePropertyName("PNCode");
                        jsonWriter.WriteValue(item.PNCode);

                        jsonWriter.WritePropertyName("Vol");
                        jsonWriter.WriteValue(item.VolumneInml.ToPNString());

                        jsonWriter.WritePropertyName("VolFull");
                        jsonWriter.WriteValue(item.VolumneInml.ToPNFullString(true));

                        jsonWriter.WritePropertyName("Overage");
                        jsonWriter.WriteValue(overage.ToPNString());

                        jsonWriter.WritePropertyName("OverageFull");
                        jsonWriter.WriteValue(overage.ToPNFullString(true));

                        jsonWriter.WritePropertyName("VolWithOverage");
                        jsonWriter.WriteValue(volWithOverage.ToPNString());

                        jsonWriter.WritePropertyName("VolWithOverageFull");
                        jsonWriter.WriteValue(volWithOverage.ToPNFullString(true));

                        jsonWriter.WriteEndObject();
                    }
                    jsonWriter.WriteEndArray();
                    jsonWriter.WriteEndObject();

                    jsonWriter.WriteEndObject();
                    jsonWriter.Flush();
                    jsonWriter.Close();
                }

                writer.Flush();
                writer.Close();
                return writer.ToString();
            }
        }

        /// <summary>
        /// Caculates ingredient totals for all the regimens in the list
        /// </summary>
        /// <param name="ingredientDBNames">List of ingredients to calculate (must existing in PNProduct table)</param>
        /// <returns>ingredient totals</returns>
        public IEnumerable<double> CalculateTotals(IEnumerable<string> ingredientDBNames)
        {
            PNProduct products = PNProduct.GetInstance();
            int count = ingredientDBNames.Count();
            double[] ingredientTotals = new double[count];

            ingredientTotals.Initialize();

            foreach (PNRegimenItem item in this.RegimenItems)
            {
                PNProductRow product = products.FindByPNCode(item.PNCode);

                if (product != null)
                {
                    // Calculte the ingredient values for the product
                    double[] productIngs = product.CalculateIngredientValues(ingredientDBNames, item.VolumneInml).ToArray();
                    
                    // Sum up ingredient totals 
                    for (int i = 0; i < count; i++)
                        ingredientTotals[i] += productIngs[i];
                }
            }

            return ingredientTotals;
        }

        /// <summary>
        /// Caculates ingredient total for all the regimens in the list
        /// Ingredient value is converted to 3 sig fig using To3SigFigish. 
        /// </summary>
        /// <param name="ingredientDBName">Ingredients to calculate (must existing in PNProduct table)</param>
        /// <returns>ingredient total</returns>
        public double CalculateTotal(string ingredientDBName)
        {
            PNProduct products = PNProduct.GetInstance();
            double ingredientTotals = 0.0;

            foreach (PNRegimenItem item in this.RegimenItems)
            {
                PNProductRow product = products.FindByPNCode(item.PNCode);

                // Calculte the ingredient values for the product (and add to total)
                if (product != null)
                    ingredientTotals += product.CalculateIngredientValue(ingredientDBName, item.VolumneInml);
            }

            return ingredientTotals;
        }

        /// <summary>Caclulates the overage for the product (will be for full 48Hrs if 48Hr supply)</summary>
        /// <param name="PNCode">PNCode of product to calculte overage for</param>
        /// <param name="totalVolume">This is total of either the aqueous, lipid or combined depening on product type, and it regimen is combined (total WITHOUT overage)</param>
        /// <returns>product overage</returns>
        public double CalculateProductOverage(string PNCode, double totalVolume)
        {
            PNProductRow  product = PNProduct.GetInstance().FindByPNCode(PNCode);
            PNRegimenItem item    = this.regimenItems.FindByPNCode(PNCode);

            double overageVolume = (!this.Regimen.IsCombined && (product.AqueousOrLipid == PNProductType.Lipid) ? this.Regimen.OverageLipid : this.Regimen.OverageAqueousOrCombined) ?? 0;

            double itemVolume   =  item.VolumneInml * this.Regimen.SupplyMultiplier;

            double multiplyFactor= (overageVolume + totalVolume) / totalVolume; //TH Moved from below. MultiplyFactor should NOT include 48 Supply (Overage is per BAG) (TFS 181852)

            return Math.Max((itemVolume * multiplyFactor) - itemVolume, 0.0);
        }

        /// <summary>
        /// Calls sp pPNIngredientsToProducts to run the ingredient to product rules (RuleType 0) against the backboard
        /// Returns map of ingredient to PNCode (note ingredient can be in form NaCl, not just Na or Cl)
        /// </summary>
        /// <param name="patient">Patient info</param>
        /// <param name="ageRange">Patient age range</param>
        /// <param name="dosingWeightInKg">Patient dosing weight</param>
        /// <returns>map of ingredient to PNCode (note ingredient can be in form NaCl)</returns>
        public Dictionary<string,string> GetProductToIngredientAllocation()
        {
            PNBlackboard blackboard = new PNBlackboard();
            Dictionary<string,string> pnCodeToIngredient;

            // Create the blackboard row
            PNBlackboardRow blackboardRow = blackboard.Add();
            blackboardRow.SetFromPatientInfo(this.Patient);
            blackboardRow.WeightInkg = this.Prescription.DosingWeightInkg;
            blackboard.Save();

            // Run the PNIngredient to products sp
            try
            {
                this.duplicateIngredientRuleViolations = new List<string>();    // TFS32363 20Apr12 XN keep list of duplicate ingredient to rule violations so can report in Validation method
                pnCodeToIngredient = PNBlackboard.PNIngredientsToProducts(blackboardRow.PNBlackboardID, this.Prescription.PerKiloRules, ref duplicateIngredientRuleViolations);
            }
            finally
            {
                // Remove the black board row
                blackboard.Remove(blackboardRow);
                blackboard.Save();
            }

            // Return restuls
            return pnCodeToIngredient;
        }

        /// <summary>
        /// This procedure looks at the lipid portion of the regimen and works out how to fit it into syringes.
        /// It takes the lipid volume and existing lipid overage volume
        /// It returns the revised LipidOverage volume, the number of syringes required and a message string.
        /// If iNumberOfSyringes>0 then it also sets the rtf file name (including 'x:\dispdata.xxx\')
        /// If syringes are not appropriate or are not possible then it sets iNumberOfSyringes=0
        /// and may return an explanatory message if this was due to a configuration error.
        /// Note that no account is taken of mixed or aqueous only regimens; it is the responsibility of
        /// the calling routine to decide when to call the LipidSyringes procedure.
        /// </summary>
        private void CalculateLipidSyringe(out int numberOfSyringes, out double lipidOverage, out string message, out string syringeDescription)
        {
            double lipidVolume = this.RegimenItems.FindByAqueousOrLipid(PNProductType.Lipid).CalculateTotal(PNIngDBNames.Volume);

            message = string.Empty;
            syringeDescription = string.Empty;
            numberOfSyringes = 0;
            lipidOverage = 0.0;

            int iMaximumNumberOfSyringes = WConfigurationController.LoadAndCache<int>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "MaximumNumberOfSyringes", "0", false);
            if (lipidVolume <= 0)
                iMaximumNumberOfSyringes = 0;

	        if (iMaximumNumberOfSyringes < 0)
                message += "MaximumNumberOfSyringes in Wconfiguration cannot be negative\n";
            else if (iMaximumNumberOfSyringes > 0)
            {
	            syringeDescription = WConfigurationController.LoadAndCache<string>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "SyringeDescription", string.Empty, false);
                if (string.IsNullOrEmpty(syringeDescription))
                    message += "Syringe description missing from Wconfiguration\n";
                else if (syringeDescription.Length > 30)
                    message += "Syringe description in Wconfiguration is too long (max 30 characters)\n";

                double maximumVolumePerSyringe = WConfigurationController.LoadAndCache<double>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "MaximumVolumePerSyringe", Double.NaN.ToString(), false);
                if (maximumVolumePerSyringe == Double.NaN)
                    message += "MaximumVolumePerSyringe missing from Wconfiguration\n";
                else if ((maximumVolumePerSyringe < 1.0) || (maximumVolumePerSyringe > 100.0))
                    message += "MaximumVolumePerSyringe in Wconfiguration must be between 1ml and 100ml\n";

                double minimumVolumePerSyringe = WConfigurationController.LoadAndCache<double>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "MinimumVolumePerSyringe", Double.NaN.ToString(), false);
                if (minimumVolumePerSyringe == Double.NaN)
                    message += "MinimumVolumePerSyringe missing from Wconfiguration\n";
                else if ((minimumVolumePerSyringe < 0) || (minimumVolumePerSyringe > maximumVolumePerSyringe))
                    message += "MinimumVolumePerSyringe must be between OveragePerSyringe and MaximumVolumePerSyringe\n";

                double overagePerSyringe = WConfigurationController.LoadAndCache<double>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "OveragePerSyringe", Double.NaN.ToString(), false);
                if (overagePerSyringe == Double.NaN)
                    message += "OveragePerSyringe missing from Wconfiguration\n";
                else if ((overagePerSyringe < 0) || (overagePerSyringe > maximumVolumePerSyringe))
                    message += "overagePerSyringe must be between 0 and MaximumVolumePerSyringe\n";

                // TFS30748 29Mar12 XN
                // double overagePerRegimen = WConfigurationController.LoadAndCache<double>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "OveragePerSyringe", Double.NaN.ToString(), false);
                double overagePerRegimen = WConfigurationController.LoadAndCache<double>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "OveragePerRegimen", Double.NaN.ToString(), false);
                if (overagePerRegimen == Double.NaN)
                    message += "OveragePerRegimen missing from Wconfiguration\n";
                else if (overagePerRegimen < 0)
                    message += "OveragePerRegimen cannot be less than zero.\n";
      
                string fillEquallyStr = WConfigurationController.LoadAndCache<string>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "FillEqually", string.Empty, false);
                if (string.IsNullOrEmpty(fillEquallyStr))
                    message += "FillEqually missing from Wconfiguration\n";
                bool fillEqually = BoolExtensions.PharmacyParse(fillEquallyStr);

                string RTFForSyringe = WConfigurationController.LoadAndCache<string>(SessionInfo.SiteID, "D|PN", "LipidSyringes", "RTFforSyringe", string.Empty, false);
                if (string.IsNullOrEmpty(RTFForSyringe))
                    message += "RTFforSyringe missing fromWconfiguration\n";
    
                // since the last syringe in the sequence could have a very tiny quantity to be filled. Advise setting a minimum volume per syringe, or fill all equally.
                if (string.IsNullOrEmpty(message) && !fillEqually && minimumVolumePerSyringe.IsZero())
                    message += "MinimumVolumePerSyringe=0 and FillEqually=No in WConfiguration\nPlease set 'MinimumVolumePerSyringe' so as to avoid a tiny volume in the last syringe.\n";

                if (string.IsNullOrEmpty(message))
                {
                    // The overage and total volume are calculated as follows;
                    double usableSyringeVolume      = maximumVolumePerSyringe - overagePerSyringe;           // usable mls
                    double lipidVolWithBasicOverage = lipidVolume + overagePerRegimen;                       // lipid vol + fixed overage
                    
                    numberOfSyringes = (int)Math.Floor(lipidVolWithBasicOverage / usableSyringeVolume);        
	                double partSyringe = lipidVolWithBasicOverage - numberOfSyringes * usableSyringeVolume;  // any left over
                    if (partSyringe > 0)
                        numberOfSyringes += 1;                                                               // last one is part filled
	    
                    if (numberOfSyringes > iMaximumNumberOfSyringes)    // TFS31076 2Apr12 XN Fixed issue where did not spot correct sysringe limit (as compated against max syringe volume!!!) 
                    {
                        // Too many syrines so use bags
                        numberOfSyringes = 0;
                        RTFForSyringe    = string.Empty;
                    }
                    else
                    {
                        // We now know we can fit the required amount into NumberOfSyringes
                        // Now check if this needs increasing to fill the last syringe
                        lipidOverage =  overagePerRegimen;                                                  // start with fixed overage
                        lipidOverage += numberOfSyringes * overagePerSyringe;                               // add the overage per syringe
                        //if (partSyringe + overagePerSyringe < minimumVolumePerSyringe)                    // round up last one if necessary
                        if (partSyringe > 0 && partSyringe + overagePerSyringe < minimumVolumePerSyringe)   // round up last one if necessary TFS31076 11Apr12 XN prevent adding extra when no part volume
                            lipidOverage += minimumVolumePerSyringe - partSyringe - overagePerSyringe;
                    }
                }
            }
        }

        /// <summary>
        /// Limits regimen product volumes to Max, and Max Per Kg for the product.
        /// Returns a broken rule if any product are limited
        /// 21Mar13 XN
        /// </summary>
        /// <returns>Broken rule contiain limited product, or null if no products were limited</returns>
        public PNBrokenRule? ValidateProductLimits()
        {
            StringBuilder brokenRules = new StringBuilder();
            foreach (PNRegimenItem item in this.RegimenItems)
            {
                PNProductRow product = item.GetProduct();
                double? volumeInml = item.VolumneInml;
                if (product.LimitToMaxmlTotal(ref volumeInml))
                    brokenRules.AppendFormat("{0} reduced from {1} ml to {2} ml<br />", product.Description, item.VolumneInml.ToPNString(), volumeInml.Value.ToPNString());
                if (product.LimitToMaxmlPerKg(ref volumeInml, this.Prescription.DosingWeightInkg))
                    brokenRules.AppendFormat("{0} reduced from {1} ml to {2} ml<br />", product.Description, item.VolumneInml.ToPNString(), volumeInml.Value.ToPNString());

                item.VolumneInml = volumeInml.Value;
            }

            if (brokenRules.Length > 0)
                return new PNBrokenRule(null, PNBrokenRuleType.Warning, "Following were reduced as exceed maximum dose", brokenRules.ToString());
            else
                return null;
        }

        public IEnumerable<PNBrokenRule> Validate()
        {
            List<PNBrokenRule> brokenRules = new List<PNBrokenRule>();

            // Check the site (done first incase it changes)
            if (Regimen.LocationID_Site != SessionInfo.SiteID)
            {
                SiteProcessor sites = new SiteProcessor();
                Site          site  = sites.LoadBySiteID(SessionInfo.SiteID);
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "Different site", string.Empty);
                rule.Explanation = string.Format("This regimen was created on a different site ({0} - {1} {2})", site.AbbreviatedName, site.FullName, site.Number);
                brokenRules.Add(rule);
            }

            PNProduct    products    = PNProduct.GetInstance();
            PNIngredient ingredients = PNIngredient.GetInstance();
            
            PNRule rules = new PNRule(); 
            //rules.LoadBySiteIDAndRuleType(SessionInfo.SiteID, RuleType.IngredientByProduct);      TFS30845 30Mar12 XN Improve Pn regimen start-up checks
            rules.LoadBySiteIDRuleTypeAndPerKilo(SessionInfo.SiteID, RuleType.IngredientByProduct, Prescription.PerKiloRules); 

            // Verify the rule data (first check they have loaded)

            // For RuleType.IngredientByProduct checks PNCode exists in PNProduct table
            // List<PNRuleRow> missingPNCode = rules.Where(r => !string.IsNullOrEmpty(r.PNCode) && (products.FindByPNCode(r.PNCode) == null)).ToList();     TFS30845 30Mar12 XN Improve Pn regimen start-up checks
            List<PNRuleRow> missingPNCode = rules.Where(r => !string.IsNullOrEmpty(r.PNCode) && (products.FindByPNCode(r.PNCode) == null || !products.FindByPNCode(r.PNCode).InUse)).ToList();
            if (missingPNCode.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Invalid ingredient to product rule", string.Empty);
                rule.Explanation = missingPNCode.Select(i => string.Format("Rule {0} references PNCode '{1}' that does not exist in PN product list, or is out of use", i.RuleNumber, i.PNCode)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // For RuleType.IngredientByProduct checks Ingredient exists in PNIngredient table
            List<string> requiredIngredients = typeof(PNIngCode).GetFields(BindingFlags.Public | BindingFlags.Static).Select(i => (string)i.GetValue(null)).ToList();
            List<string> invalidIngredient = requiredIngredients.Where(i => !rules.Any(r => r.Ingredient.EqualsNoCaseTrimEnd(i))).ToList();
            if (invalidIngredient.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Invalid ingredient to product rule", string.Empty);
                rule.Explanation = invalidIngredient.Select(i => string.Format("No ingredient rule provided for '{0}'", i)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check for duplicate ingredient to product rules TFS32363 20Apr12 XN
            if (duplicateIngredientRuleViolations.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Duplicate ingredient to product rule", string.Empty);
                rule.Explanation = duplicateIngredientRuleViolations.Select(i => string.Format("More than one rule fired for ingredient {0}.", i)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check there is a rule for each ingredient
            // TFS30845 2Apr12 XN Perform check that all ingredients are supplied by a single rule
            List<string> missingIngredients = new List<string>();
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Dil  ))  { missingIngredients.Add(PNIngCode.Dil  ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.NaCl ))  { missingIngredients.Add(PNIngCode.NaCl ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.KCl  ))  { missingIngredients.Add(PNIngCode.KCl  ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.KPO4 ))  { missingIngredients.Add(PNIngCode.KPO4 ); }
            //if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Vol  ))  { missingIngredients.Add(PNIngCode.Vol  ); }  TFS32337 20Apr12 XN Should not perform check for volume rule as volume is handled differently
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.N    ))  { missingIngredients.Add(PNIngCode.N    ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Gluc ))  { missingIngredients.Add(PNIngCode.Gluc ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Fat  ))  { missingIngredients.Add(PNIngCode.Fat  ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Na   ))  { missingIngredients.Add(PNIngCode.Na   ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.K    ))  { missingIngredients.Add(PNIngCode.K    ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Ca   ))  { missingIngredients.Add(PNIngCode.Ca   ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Mg   ))  { missingIngredients.Add(PNIngCode.Mg   ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Zn   ))  { missingIngredients.Add(PNIngCode.Zn   ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.PO4  ))  { missingIngredients.Add(PNIngCode.PO4  ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Se   ))  { missingIngredients.Add(PNIngCode.Se   ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Cu   ))  { missingIngredients.Add(PNIngCode.Cu   ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Vaqu ))  { missingIngredients.Add(PNIngCode.Vaqu ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Vlip ))  { missingIngredients.Add(PNIngCode.Vlip ); }
            if (!this.ingredientToPNCode.ContainsKey(PNIngCode.Fe   ))  { missingIngredients.Add(PNIngCode.Fe   ); }
            if (missingIngredients.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Invalid ingredient to product rule", string.Empty);
                rule.Explanation = missingIngredients.Select(i => string.Format("Ingredient {0} not supplied by rule, or rule is out of use", i)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Verify product data

            // Check invalid container volume
            List<PNProductRow> invalidProducts = products.Where(p => p.ContainerVolumeInml < 0.01).ToList();
            if (invalidProducts.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Following have invalid container volume", string.Empty);
                rule.Explanation = invalidProducts.Select(p => p.PNCode + " - " + p.Description).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Test potassium chloride (only contains potassium and chloride)
            if (!invalidIngredient.Any() && !missingPNCode.Any() && !missingIngredients.Any())
            {
                PNProductRow KClProduct = products.FindByPNCode(this.KClPNCode);
                if ((KClProduct.GetIngredient(PNIngDBNames.Potassium) <= 0.0) || (KClProduct.GetIngredient(PNIngDBNames.Chloride) <= 0.0) ||
                    (ingredients.FindByForPNProduct(false).Count(i => (KClProduct.GetIngredient(i.DBName) ?? 0.0) > 0.0) != 2))
                    brokenRules.Add(new PNBrokenRule(null, PNBrokenRuleType.Critical, "Product configuration", "Potassium Chloride has not been configured correctly"));

                // Test sodium chloride (only contains sodium and chloride)
                PNProductRow NaClProduct = products.FindByPNCode(this.NaClPNCode);
                if ((NaClProduct.GetIngredient(PNIngDBNames.Sodium) <= 0.0) || (NaClProduct.GetIngredient(PNIngDBNames.Chloride) <= 0.0) ||
                    (ingredients.FindByForPNProduct(false).Count(i => (NaClProduct.GetIngredient(i.DBName) ?? 0.0) > 0.0) != 2))
                    brokenRules.Add(new PNBrokenRule(null, PNBrokenRuleType.Critical, "Product configuration", "Sodium Chloride has not been configured correctly"));

                // Test diluent (Normally 5% Gl, but may be WFI or other glucose concentration.)
                PNProductRow diluentProduct = products.FindByPNCode(this.DiluentPNCode);
                if (ingredients.FindByForPNProduct(false).Any(i => (i.DBName != PNIngDBNames.Glucose) && (i.DBName != PNIngDBNames.Calories) && !(diluentProduct.GetIngredient(i.DBName) ?? 0.0).IsZero()))
                    brokenRules.Add(new PNBrokenRule(null, PNBrokenRuleType.Critical, "Product configuration", "Check that Glucose or WFI have been specified as diluent"));

                // Test Potassium Phosphate (though not realy used in this version)
                PNProductRow KPO4Product = products.FindByPNCode(this.KPO4PNCode);
                //if ((KPO4Product.GetIngredient(PNIngDBNames.InorganicPhosphate) <= 0.0) && (KPO4Product.GetIngredient(PNIngDBNames.Potassium) <= 0.0))    TFS30845 30Mar12 XN Improve Pn regimen start-up checks
                if ((KPO4Product.GetIngredient(PNIngDBNames.InorganicPhosphate) <= 0.0) || (KPO4Product.GetIngredient(PNIngDBNames.Potassium) <= 0.0))
                    brokenRules.Add(new PNBrokenRule(null, PNBrokenRuleType.Critical, "Product configuration", "Potassium phosphate has not been configured correctly"));

                // Test Vit Lipid contains Vitamin E
                PNProductRow vitLipidProduct = products.FindByPNCode(ingredientToPNCode[PNIngCode.Vlip]);
                if ((vitLipidProduct != null) && vitLipidProduct.GetIngredient(PNIngDBNames.VitaminE) <= 0.0)
                    brokenRules.Add(new PNBrokenRule(null, PNBrokenRuleType.Critical, "Product configuration", "The lipid soluble vitamin product does not contain vitamin E."));
            }

            // Test kcal/g fat is suitalbe
            if (this.kcalPerGramFat < 8.0 || this.kcalPerGramFat > 10.0)
                brokenRules.Add(new PNBrokenRule(null, PNBrokenRuleType.Critical, "WConfiguration configuration", "Invalid WConfiguration setting for kcalPerGramFat."));

            // Test kcal/g glucose is suitalbe
            if (this.kcalPerGramGlucose < 3.4 || this.kcalPerGramGlucose > 4)
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "WConfiguration configuration", "Invalid WConfiguration setting for kcalPerGramGlucose.");
                brokenRules.Add(rule);
            }

            // Validate patients DOB
            if (this.Patient.DOB.HasValue)
            {
                List<WeightAgeInfo> weightAgeInfo = PNSettings.WeightAge.GetWeightAge(this.Patient.Gender);
                double years = PNUtils.YearsDifference(this.Patient.DOB.Value, DateTime.Now);
                if (years > 130)
                {
                    PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Invalid Age", "Patient is too old, entered as age " + ((int)Math.Round(years)).ToString() + " years");
                    brokenRules.Add(rule);
                }
                else if (this.Patient.DOB.Value > DateTime.Now)
                {
                    PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Invalid Date of Birth", "Dates in the future cannot be entered: " + this.Patient.DOB.Value.ToPharmacyDateString());
                    brokenRules.Add(rule);
                }
                else if (!weightAgeInfo.Any())
                {
                    PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "WConfiguration configuration", "Weight age ranges missing from configuration.");
                    brokenRules.Add(rule);
                }
                else
                {
                    double months = years * 12.0;
                    int w;
                    for (w = 0; w < weightAgeInfo.Count() - 2; w++)
                    {
                        if (weightAgeInfo[w].age >= months && months < weightAgeInfo[w + 1].age)
                            break;
                    }

                    double fraction  = (months - weightAgeInfo[w].age) / (weightAgeInfo[w + 1].age - weightAgeInfo[w].age);
                    double minWeight = weightAgeInfo[w].WeightLow    + fraction * (weightAgeInfo[w + 1].WeightLow    - weightAgeInfo[w].WeightLow   );
                    double maxWeight = weightAgeInfo[w].WeightHeight + fraction * (weightAgeInfo[w + 1].WeightHeight - weightAgeInfo[w].WeightHeight);

                    minWeight = minWeight.To3SigFigish();
                    maxWeight = maxWeight.To3SigFigish();

                    if (this.Prescription.DosingWeightInkg > maxWeight)
                    {
                        PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "Weight warning", string.Empty);
                        if (years < 3.0)
                            rule.Explanation = string.Format("Age is {0:#.#} months[cr]Weight of {1} kg is high for this age (Range {2} kg to {3} kg)", months, Prescription.DosingWeightInkg, minWeight, maxWeight);
                        else
                            rule.Explanation = string.Format("Age is {0:#} years[cr]Weight of {1} kg is high for this age (Range {2} kg to {3} kg)", years, Prescription.DosingWeightInkg, minWeight, maxWeight);
                        brokenRules.Add(rule);
                    }
                    else if (this.Prescription.DosingWeightInkg < minWeight)
                    {
                        PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "Weight warning", string.Empty);
                        if (years < 3.0)
                            rule.Explanation = string.Format("Age is {0:#.#} months[cr]Weight of {1} kg is low for this age (Range {2} kg to {3} kg)", months, Prescription.DosingWeightInkg, minWeight, maxWeight);
                        else
                            rule.Explanation = string.Format("Age is {0:#} years[cr]Weight of {1} kg is low for this age (Range {2} kg to {3} kg)", years, Prescription.DosingWeightInkg, minWeight, maxWeight);
                        brokenRules.Add(rule);
                    }
                }
            }
            else
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Invalid Date of Birth", "Patient has no DOB");
                brokenRules.Add(rule);
            }
            
            // Check all ingredients have valid units
            List<PNIngredientRow> invalidUnits = ingredients.Where(i => i.GetUnit() == null).ToList();
            if (invalidUnits.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Invalid ingredient units", string.Empty);
                rule.Explanation = invalidUnits.Select(i => i.Description + "\t-\t" + i.UnitDescription).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check all products in regimen still exists (occurs normaly if regimen was created on different site)
            List<PNRegimenItem> unsupportedProduct = this.regimenItems.Where(i => i.GetProduct() == null).ToList();
            if (unsupportedProduct.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "Invalid regimen products", string.Empty);
                rule.Explanation = unsupportedProduct.Select(i => string.Format("Product {0} is not supported by this site.", i.PNCode)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check all products are still in use
            List<PNRegimenItem> outOfUseProducts = this.regimenItems.Where(i => !i.GetProduct().InUse).ToList();
            if (outOfUseProducts.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "Invalid regimen products", string.Empty);
                rule.Explanation = outOfUseProducts.Select(i => string.Format("Product {0} is out of use.", i.GetProduct().Description)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check all products are sutiable for age
            List<PNRegimenItem> invalidAgeProducts = this.regimenItems.Where(i => Prescription.PerKiloRules ? !i.GetProduct().ForPaediatric : !i.GetProduct().ForAdult).ToList();
            if (invalidAgeProducts.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "Invalid regimen products", string.Empty);
                rule.Explanation = outOfUseProducts.Select(i => string.Format("Product {0} has not suitable for {1}.", i.GetProduct().Description, Prescription.AgeRage)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            return brokenRules;
        }

        /// <summary>
        /// Performs a stablity check for the regimen (RuleType 4)
        /// Return rules that failed
        /// </summary>
        public IEnumerable<PNBrokenRule> PerformStabilityCheck()
        {
            PNBlackboard blackboard = new PNBlackboard();
            List<string> PNCodesMissed, PNCodesInvalidVol;
            List<PNBrokenRule> brokenRules = new List<PNBrokenRule>();

            // Check for negative values
            List<PNRegimenItem> negativeItems = regimenItems.Where(i => i.VolumneInml < 0).ToList();
            if (negativeItems.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Following have negative volume", string.Empty);
                rule.Explanation = negativeItems.Select(i => i.GetProduct().Description).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check all products are still in use
            List<PNRegimenItem> outOfUseProducts = this.regimenItems.Where(i => !i.GetProduct().InUse).ToList();
            if (outOfUseProducts.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Invalid regimen products", string.Empty);
                rule.Explanation = outOfUseProducts.Select(i => string.Format("Product {0} is out of use.", i.GetProduct().Description)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check for age range
            HashSet<string> PNCodesForThisAgeRange = new HashSet<string>(PNProduct.GetInstance().FindByAgeRange(Prescription.AgeRage).Select(i => i.PNCode));
            List<PNRegimenItem> invalidAgeRangeItems = regimenItems.Where(i => i.VolumneInml > 0 && !PNCodesForThisAgeRange.Contains(i.PNCode)).ToList();
            if (invalidAgeRangeItems.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Following are not for " + Prescription.AgeRage.ToString() + " use", string.Empty);
                rule.Explanation = invalidAgeRangeItems.Select(i => i.GetProduct().Description).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check against product max dose
            List<PNRegimenItem> greaterThanMaxDose = regimenItems.Where(i => (i.GetProduct().MaxmlTotal > 0.0) && (i.VolumneInml > i.GetProduct().MaxmlTotal)).ToList();
            if (greaterThanMaxDose.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "Following exceed their maximum dose", string.Empty);
                rule.Explanation = greaterThanMaxDose.Select(i => string.Format("{0} exceeds {1:0.##} ml", i.GetProduct().Description, i.GetProduct().MaxmlTotal)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }

            // Check against product max per kg
            List<PNRegimenItem> greaterThanMaxDosePerKg = regimenItems.Where(i => (i.GetProduct().MaxmlPerKg > 0.0) && ((i.VolumneInml / Prescription.DosingWeightInkg) > i.GetProduct().MaxmlPerKg)).ToList();
            if (greaterThanMaxDosePerKg.Any())
            {
                PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Warning, "Following exceed their maximum dose per kg", string.Empty);
                rule.Explanation = greaterThanMaxDosePerKg.Select(i => string.Format("{0} exceeds {1:0.##} ml/kg", i.GetProduct().Description, i.GetProduct().MaxmlPerKg)).ToCSVString("[cr]");
                brokenRules.Add(rule);
            }


            // Perform Lipid syringe overage check
            //if (!this.Regimen.IsCombined)     
            if (!this.Regimen.IsCombined && !this.Regimen.Supply48Hours)    // TFS30748 29Mar12 XN Though not really somthing that would happen, prevent using syringes if 48 hour as makes no sense
            {
                double tempLipidOverage = this.Regimen.OverageLipid ?? 0;
                double totalLipid = this.RegimenItems.FindByAqueousOrLipid(PNProductType.Lipid).CalculateTotal(PNIngDBNames.Volume);

                int numberOfSyringes;
                double lipidOverage;
                string errors, syringeDescription;
                this.CalculateLipidSyringe(out numberOfSyringes, out lipidOverage, out errors, out syringeDescription);
                if (!string.IsNullOrEmpty(errors))
                {
                    numberOfSyringes = 0;
                    PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Critical, "Configuration Error", string.Empty);
                    rule.Explanation = "Please check and correct the following:[cr][cr]" + errors;
                    brokenRules.Add(rule);
                }
                else if (numberOfSyringes > 0)
                {
                    PNBrokenRule rule = new PNBrokenRule(null, PNBrokenRuleType.Info, "Lipid overage", string.Empty);
                    if (this.Regimen.OverageLipid.HasValue && (lipidOverage != this.Regimen.OverageLipid.Value))
                    {
                        rule.Explanation += string.Format("Lipid overage has been changed from {0:0.##} ml to {1:0.##} ml[cr]", this.Regimen.OverageLipid, lipidOverage);
                        this.Regimen.OverageLipid = lipidOverage;
                    }
                    double lipidVolume = this.RegimenItems.FindByAqueousOrLipid(PNProductType.Lipid).CalculateTotal(PNIngDBNames.Volume);
                    rule.Explanation += string.Format("Lipid portion of {0} ml will be in {1} x {2}.", lipidVolume.ToPNString(), numberOfSyringes, modShared.XMLEscape(syringeDescription));    // TFS30954 30Mar12 XN escaped the string to prevent scrip errors
                    brokenRules.Add(rule);  // TFS30748 29Mar12 XN Add so reports the info back to user
                }

                // TFS30748 29Mar12 XN Save number of lipid syringes to db
                this.Regimen.SupplyLipidSyringe = (numberOfSyringes > 0);
                this.Regimen.NumberOfSyringes   = numberOfSyringes;
            }
            else
            {   // TFS30748 29Mar12 XN Save number of lipid syringes to db
                this.Regimen.SupplyLipidSyringe = false;
                this.Regimen.NumberOfSyringes   = 0;
            }

            if (!brokenRules.Any(r => r.Type == PNBrokenRuleType.Critical))
            {
                // Create the blackboard row
                PNBlackboardRow blackboardRow = blackboard.Add();
                blackboardRow.SetFromPatientInfo    (this.Patient                   );
                blackboardRow.SetFromRegimen        (this.Regimen, this.RegimenItems);
                blackboardRow.CalciumPhosphateSolubility = this.CheckCaPO4Solubility();
                blackboardRow.Osmolality                 = this.CalculateOsmolality(out PNCodesMissed, out PNCodesInvalidVol);
                blackboardRow.WeightInkg = this.Prescription.DosingWeightInkg;
                blackboard.Save();

                // Run the sp
                try
                {
                    brokenRules.AddRange(PNBlackboard.PNCheckRules(blackboardRow.PNBlackboardID, this.Prescription.PerKiloRules));
                }
                finally
                {
                    // Remove the black board row
                    if (!PNSettings.ViewAndAdjust.GetKeepRowsOnBlackboard())
                        blackboard.Remove(blackboardRow);
                    blackboard.Save();
                }
            }

            return brokenRules;
        }

        /// <summary>
        /// Adjusts the regimen volume while maintaining the glucose level at it's orignal level, 
        /// by replacing all glucose products, with the selected glucose item, and the universal diluent (if mixing)
        /// TFS31246 5Apr12 XN Updated calculation to take factor in if diluent contains glucose
        /// </summary>
        /// <param name="mixing">If mixing glucose with diluent</param>
        /// <param name="glucosePNCode">Glucose product to use</param>
        /// <param name="requiredTotalVolumeInml">Required total volume required</param>
        /// <param name="info">Extra info</param>
        public void AdjustVolume(bool mixing, string glucosePNCode, double requiredTotalVolumeInml, PNViewAndAdjustInfo info)
        {
            double originalGlucoseAmount = this.CalculateTotal(PNIngDBNames.Glucose);

            // Remove all glucose items
            regimenItems.FindByOnlyContainGlucose().ToList().ForEach(p => this.RemoveItem(p.PNCode));

            // Remove diluent
            this.RemoveItem(this.DiluentPNCode);

            // Calculate the volume and glucose content required
            double volumeRequired  = requiredTotalVolumeInml - this.CalculateTotal(PNIngDBNames.Volume );
            double glucoseRequired = originalGlucoseAmount   - this.CalculateTotal(PNIngDBNames.Glucose);

            if (mixing)
            {
                // Calculate volume of diluent required
                double glucoseProductGlucoseConentration = PNProduct.GetInstance().FindByPNCode(glucosePNCode     ).CalculateIngredientValue(PNIngDBNames.Glucose, 1);
                double diluentGlucoseConentration        = PNProduct.GetInstance().FindByPNCode(this.DiluentPNCode).CalculateIngredientValue(PNIngDBNames.Glucose, 1);
                double diluentVolume = (glucoseRequired - (volumeRequired * glucoseProductGlucoseConentration)) / (diluentGlucoseConentration - glucoseProductGlucoseConentration);
                double glucoseVolume = (glucoseRequired - (diluentVolume * diluentGlucoseConentration)) / glucoseProductGlucoseConentration;

                if (diluentVolume < 1)
                {
                    glucoseVolume += diluentVolume;                   // If diluent volume is too small then just add to glucode
                    this.UpdateItem(glucosePNCode, glucoseVolume);    

                    // Make a small adjustment for rounding issues
                    double diffVolume = this.CalculateTotal(PNIngDBNames.Volume) - requiredTotalVolumeInml;
                    this.UpdateItem(glucosePNCode, glucoseVolume - diffVolume);
                }
                else
                {
                    this.UpdateItem(glucosePNCode,      glucoseVolume);
                    this.UpdateItem(this.DiluentPNCode, diluentVolume);

                    // Make a small adjustment for rounding issues
                    double diffVolume = this.CalculateTotal(PNIngDBNames.Volume) - requiredTotalVolumeInml;
                    this.UpdateItem(this.DiluentPNCode, diluentVolume - diffVolume);
                }
            }
            else // not mixing so make up volume using the selected glucose product
                this.UpdateItem(glucosePNCode, volumeRequired);
        }

        /// <summary>
        /// Adjusts regimen calories while maintaining the volume level at it's orignal level, 
        /// by replacing all glucose products, with the selected glucose item, and the universal diluent (if mixing)
        /// TFS31246 5Apr12 XN Updated calculation to take factor in if diluent contains glucose
        /// </summary>
        /// <param name="mixing">If mixing glucose with diluent</param>
        /// <param name="glucosePNCode">Glucose product to use</param>
        /// <param name="requiredTotalCalories">Required total calories required</param>
        /// <param name="info">Extra info</param>
        public void AdjustCalories(bool mixing, string glucosePNCode, double requiredTotalCalories, PNViewAndAdjustInfo info)
        {
            PNProductRow glucoseProduct = PNProduct.GetInstance().FindByPNCode(glucosePNCode);

            double originalVolumeAmount = this.CalculateTotal(PNIngDBNames.Volume);

            // Remove all glucose items
            regimenItems.FindByOnlyContainGlucose().ToList().ForEach(p => this.RemoveItem(p.PNCode));

            // Remove diluent
            this.RemoveItem(this.DiluentPNCode);

            // Calculate amount of glucose required to provide the calorie content
            double calorieDifference = requiredTotalCalories - this.CalculateTotal(PNIngDBNames.Calories);
            double glucoseRequired   = calorieDifference / this.kcalPerGramGlucose;
            double volumeRequired    = originalVolumeAmount - this.CalculateTotal(PNIngDBNames.Volume );

            // If mixing set universal diluent to maintain the volume (else just topup the glucose level)
            if (mixing)
            {
                // Calculate volume of diluent required
                double glucoseProductGlucoseConentration = PNProduct.GetInstance().FindByPNCode(glucosePNCode     ).CalculateIngredientValue(PNIngDBNames.Glucose, 1);
                double diluentGlucoseConentration        = PNProduct.GetInstance().FindByPNCode(this.DiluentPNCode).CalculateIngredientValue(PNIngDBNames.Glucose, 1);
                double diluentVolume = (glucoseRequired - (volumeRequired * glucoseProductGlucoseConentration)) / (diluentGlucoseConentration - glucoseProductGlucoseConentration);
                double glucoseVolume = (glucoseRequired - (diluentVolume * diluentGlucoseConentration)) / glucoseProductGlucoseConentration;

                if (diluentVolume < 1)
                {
                    glucoseVolume += diluentVolume;                   // If diluent volume is too small then just add to glucode
                    this.UpdateItem(glucosePNCode, glucoseVolume);    
                }
                else
                {
                    this.UpdateItem(glucosePNCode,      glucoseVolume);
                    this.UpdateItem(this.DiluentPNCode, diluentVolume);
                }

                // Make a small adjustment for rounding issues
                double diffCalories      = this.CalculateTotal(PNIngDBNames.Calories) - requiredTotalCalories;
                double diffGlucoseVolume = (diffCalories / this.kcalPerGramGlucose) * glucoseProductGlucoseConentration;
                this.UpdateItem(glucosePNCode, glucoseVolume - diffGlucoseVolume);
            }
            else // not mixing so make up volume using the selected glucose product
                this.UpdateItem(glucosePNCode, volumeRequired);
        }

        /// <summary>
        /// Calcualtes the required glucose concentration (of glucose only products and diluent) 
        /// to reach a new set of final volume, and calorie values.
        /// </summary>
        /// <param name="newVolumeInml"></param>
        /// <param name="newCalories"></param>
        /// <param name="diluentPNCode">PNCode of univarsal diluent</param>
        /// <returns></returns>
        public double CalculateRequiredGlucoseConcentration(double? newVolume, double? newCalories, string diluentPNCode)
        {
            // Get all glucose only items from regimen
            List<PNRegimenItem> glucoseOnlyItems = this.RegimenItems.FindByOnlyContainGlucose().ToList();

            // Add universal diluent to the list if exists in regimen (if does not already exist as maybe glucose product)
            if (this.RegimenItems.FindByPNCode(diluentPNCode) != null && glucoseOnlyItems.FindByPNCode(diluentPNCode) == null)
                glucoseOnlyItems.Add(this.RegimenItems.FindByPNCode(diluentPNCode));

            double totalGlucoseOfGlucoseOnlyProducts = glucoseOnlyItems.Sum(i => i.GetProduct().CalculateIngredientValue(PNIngDBNames.Glucose, i.VolumneInml));
            double totalVolumnOfGlucoseOnlyProducts  = glucoseOnlyItems.Sum(i => i.VolumneInml);

            // Calculate differnece required to volume of glucose only products to make it up to the new volume
            double differenceInVolumeOfGlucoseOnlyProudct = totalVolumnOfGlucoseOnlyProducts;
            if (newVolume.HasValue)
                differenceInVolumeOfGlucoseOnlyProudct -= this.CalculateTotal(PNIngDBNames.Volume) - newVolume.Value;

            // Calculate differnece required to glucose amount of glucose only products to make it up to the new calorie content
            double differenceInGlucoseOfGlucoseOnlyProducts = totalGlucoseOfGlucoseOnlyProducts;
            if (newCalories.HasValue && (newCalories.Value > 0.0))
                differenceInGlucoseOfGlucoseOnlyProducts -= (this.CalculateTotal(PNIngDBNames.Calories) - newCalories.Value) / this.kcalPerGramGlucose;

            double requireConcentration = 0.0;
            if (differenceInVolumeOfGlucoseOnlyProudct > 0.0)
                requireConcentration = (differenceInGlucoseOfGlucoseOnlyProducts / differenceInVolumeOfGlucoseOnlyProudct) * 100;

            return requireConcentration;
        }

        /// <summary>
        /// Creates a HTML row for the view and adjust screen from the data
        /// </summary>
        /// <param name="item">Rows to write HTML for</param>
        /// <param name="rowType">Row type ('product, or total)</param>
        /// <param name="description">Row description</param>
        /// <param name="sortIndex">Row sort index</param>
        /// <param name="ingValues">List of ingredients to display in the row (order must match that in the view and adjust screen)</param>
        /// <param name="po4Values">List of phosphate values</param>
        /// <param name="po4DBNames">List of phosphate db names (must be in same order as po4 values)</param>
        /// <param name="markAsLipid">Mark product as being a lipid</param>
        /// <param name="isReadonly">If item is readonly</param>
        /// <returns>HTML row for view and adjust</returns>
        private string CreateRow(string PNCode, double? volumeInml, bool edited, string rowType, string description, int sortIndex, IEnumerable<double?> ingValues, IEnumerable<double> po4Values, IEnumerable<string> po4DBNames, double? totalPerKg, bool markAsLipid, bool isReadonly)
        {
            StringBuilder row = new StringBuilder();

            // <tr PNCode="VAMI090" SortIndex="100" RowType="product" VolumeInml="23.4" Phosphate_mmol="0.00" PhosphateInorganic_mmol="0.00" PhosphateOrganic_mmol="0.00" ><td><span id="Edited">&#149;</span>Vamin 9</td><td><input type="text" value="23.4"  /></td>...<td><input type="text" value="0.42"  /></td></tr >",

            // Buid up start of row data <tr PNCode="VAMI090" SortIndex="100" RowType="product" VolumeInml="23.4" 
            row.AppendFormat("<tr PNCode=\"{0}\" SortIndex=\"{1}\" RowType=\"{2}\" VolumeInml=\"{3}\" ", PNCode, sortIndex, rowType, (volumeInml.HasValue ? volumeInml.Value.ToPNString() : "-----"));

            // Add phosphate info to row <tr PNCode="VAMI090" SortIndex="100" RowType="product" VolumeInml="23.4" Phosphate_mmol="0.00" PhosphateInorganic_mmol="0.00" PhosphateOrganic_mmol="0.00" >
            int count = po4DBNames.Count();
            for(int p = 0; p < count; p++)
            {
                double valueDbl = po4Values.ElementAt(p);
                string valueStr = (rowType == "total") ? valueDbl.ToVDUIncludeZeroString() : valueDbl.ToVDUString();    // 29763 Show PO4 tooltip on total line if nothing is there
                row.AppendFormat("{0}=\"{1}\" ", po4DBNames.ElementAt(p), valueStr);
            }
            row.Append(">");

            // Add product description <tr PNCode="VAMI090" SortIndex="100" RowType="product" VolumeInml="23.4" Phosphate_mmol="0.00" PhosphateInorganic_mmol="0.00" PhosphateOrganic_mmol="0.00" ><td><span id="Edited">&#149;</span>Vamin 9</td>
            if (markAsLipid)
                description = "[" + description + "]";
            //if (rowType == "product")
            //    row.AppendFormat("<td><span id=\"Edited\">{0}</span>{1}</td>", edited ? "&#149;" : "&nbsp", description);
            //else
            //    row.AppendFormat("<td style=\"padding-left: 50px;\">{0}</td>", description);
            if (rowType == "product")
                row.AppendFormat("<td><span id=\"Edited\">{0}</span>{1}</td>", edited ? "&#149;" : "&nbsp", description.Replace("'", "&#39;")); // 23May12 XN Prevent ' causing script errors
            else
                row.AppendFormat("<td style=\"padding-left: 50px;\">{0}</td>", description.Replace("'", "&#39;"));                              // 23May12 XN Prevent ' causing script errors

            // Add ingredients <tr PNCode="VAMI090" SortIndex="100" RowType="product" VolumeInml="23.4" Phosphate_mmol="0.00" PhosphateInorganic_mmol="0.00" PhosphateOrganic_mmol="0.00" ><td><span id="Edited">&#149;</span>Vamin 9</td><td><input type="text" value="23.4"  /></td>...
            // If ingredint value is 0.0 will display empty string, and set field as readonly
            count = ingValues.Count();
            for(int p = 0; p < count; p++)
            {
                double? value = ingValues.ElementAt(p);
                string valueStr = "-----";
                string style = string.Empty;
                if (value.HasValue)
                {
                    if (double.IsNaN(value.Value))
                        valueStr = string.Empty;        // TFS29385 2Apr12 XN Display empty requirements and prescription ing as empty fields on view and adjust
                    else if (rowType == "product")
                        valueStr = value.Value.ToVDUString();
                    else 
                        valueStr = value.Value.ToVDUIncludeZeroString();

                    if (value.Value < 0.0)
                        style = "class=\"negative\"";
                }
                else
                    valueStr = "-----"; // Value not present in the prescription
                row.AppendFormat("<td {0}><input type=\"text\" value=\"{1}\" {2} oncontextmenu=\"return false;\" /></td>", style, valueStr, string.IsNullOrEmpty(valueStr) || isReadonly ? "readonly=\"readonly\" unselectable=\"on\"" : string.Empty); // 32007 XN 20Nov12 disable of select in non-editable fields TFS31267 05April12 XN disable context menu
            }

            // Add volume per kg <tr PNCode="VAMI090" SortIndex="100" RowType="product" VolumeInml="23.4" Phosphate_mmol="0.00" PhosphateInorganic_mmol="0.00" PhosphateOrganic_mmol="0.00" ><td><span id="Edited">&#149;</span>Vamin 9</td><td><input type="text" value="23.4"  /></td>...<td><input type="text" value="0.42"  /></td>
            string volumeInmlPerKgStr = "-----";
            if (totalPerKg.HasValue)
                volumeInmlPerKgStr = (rowType == "product") ? totalPerKg.Value.ToVDUString() : totalPerKg.Value.ToVDUIncludeZeroString();
            row.AppendFormat("<td><input type=\"text\" value=\"{0}\" {1} oncontextmenu=\"return false;\" /></td>", volumeInmlPerKgStr, string.IsNullOrEmpty(volumeInmlPerKgStr) || isReadonly ? "readonly=\"readonly\" unselectable=\"on\"" : string.Empty);    // 32007 XN 20Nov12 disable of select in non-editable fields TFS31267 05April12 XN disable context menu

            // Add end of row <tr PNCode="VAMI090" SortIndex="100" RowType="product" VolumeInml="23.4" Phosphate_mmol="0.00" PhosphateInorganic_mmol="0.00" PhosphateOrganic_mmol="0.00" ><td><span id="Edited">&#149;</span>Vamin 9</td><td><input type="text" value="23.4"  /></td>...<td><input type="text" value="0.42"  /></td></tr >
            row.Append("</tr >");

            return row.ToString();
        }

        #region ICloneable Members
        public object Clone()
        {
            PNProcessor clone = new PNProcessor();
            clone.regimenItems     = new List<PNRegimenItem>(this.regimenItems.Select(i => (PNRegimenItem)i.Clone()));
            clone.deletedItems     = new List<string>(this.deletedItems);
            clone.dosingWeightInml = this.dosingWeightInml;
            clone.Regimens         = new PNRegimen();
            clone.Regimens.CopyFrom(this.Regimens);
            clone.kcalPerGramFat   = this.kcalPerGramFat;
            clone.kcalPerGramGlucose= this.kcalPerGramGlucose;
            clone.Patient          = this.Patient;
            clone.Episode          = this.Episode;
            clone.Prescription     = this.Prescription;
            clone.ingredientToPNCode= new Dictionary<string,string>(this.ingredientToPNCode);
            clone.AskAdjustK       = this.AskAdjustK;
            clone.AskAdjustNa      = this.AskAdjustNa;
            return clone;
        }
        #endregion

        /// <summary>
        /// Called when IIS removes PN processor from HTTP cache. 
        /// As it is important that PN processors don't get removed (unless done manully) 
        /// this method will re added the rmoved item
        /// Note: setting CacheItemPriority.NotRemovable still does not ensure the item is kept.
        /// </summary>
        /// <param name="key">Key PN processor was given</param>
        /// <param name="value">PN processor in cache</param>
        /// <param name="reason">Reson item was removed</param>
        private static void RemovedFromCacheCallback(string key, object value, CacheItemRemovedReason reason)
        {
            if (reason == CacheItemRemovedReason.Underused)
                HttpContext.Current.Cache.Add(key, value, null, DateTime.Now.AddDays(5), Cache.NoSlidingExpiration, CacheItemPriority.NotRemovable, new CacheItemRemovedCallback(PNProcessor.RemovedFromCacheCallback));
        }

        /// <summary>
        /// Saves PN Processor to both web cache and an internal static cache (so one will work).
        /// Can store the main processor, or a copy of the processor
        /// </summary>
        /// <param name="requestID_Regimen">Regimen request ID</param>
        /// <param name="processor">processor</param>
        /// <param name="coppiedItem">If item was a copy or the main processor</param>
        public static void SaveToCache(int? requestID_Regimen, PNProcessor processor, bool coppiedItem)
        {
            string cacheName = string.Format("{0}.Cache[{1}][{2}][{3}]", typeof(PNProcessor).FullName, coppiedItem ? 1 : 0, requestID_Regimen ?? 0, SessionInfo.SessionID);
            DateTime expiryDate = DateTime.Now.AddDays(5);

            RemoveFromCache(requestID_Regimen, coppiedItem);

            HttpContext.Current.Cache.Add(cacheName, processor, null, expiryDate, Cache.NoSlidingExpiration, CacheItemPriority.NotRemovable, new CacheItemRemovedCallback(PNProcessor.RemovedFromCacheCallback));
            cachedProcessors.Add(cacheName, new CachedProcessor(expiryDate, processor));
        }

        /// <summary>Gets the PN Processor from the cache</summary>
        /// <param name="requestID_Regimen">Regimen request ID</param>
        /// <param name="coppiedItem">If item was a copy or the main processor</param>
        public static PNProcessor GetFromCache(int? requestID_Regimen, bool coppiedItem)
        {
            string cacheName = string.Format("{0}.Cache[{1}][{2}][{3}]", typeof(PNProcessor).FullName, coppiedItem ? 1 : 0, requestID_Regimen ?? 0, SessionInfo.SessionID);
            PNProcessor processor = (HttpContext.Current.Cache[cacheName] as PNProcessor);
            if (processor == null && cachedProcessors.ContainsKey(cacheName))
            {
                CachedProcessor cachedProcessor = cachedProcessors[cacheName];
                HttpContext.Current.Cache.Add(cacheName, cachedProcessor.Processor, null, cachedProcessor.ExpiryDate, Cache.NoSlidingExpiration, CacheItemPriority.NotRemovable, new CacheItemRemovedCallback(PNProcessor.RemovedFromCacheCallback));
                processor = cachedProcessor.Processor;
            }

            return processor;
        }

        /// <summary>Remove PN Processor from the cache</summary>
        /// <param name="requestID_Regimen">Regimen request ID</param>
        /// <param name="coppiedItem">If item was a copy or the main processor</param>
        public static void RemoveFromCache(int? requestID_Regimen, bool coppiedItem)
        {
            string cacheName = string.Format("{0}.Cache[{1}][{2}][{3}]", typeof(PNProcessor).FullName, coppiedItem ? 1 : 0, requestID_Regimen ?? 0, SessionInfo.SessionID);
            HttpContext.Current.Cache.Remove(cacheName);
            cachedProcessors.Remove(cacheName);

            // Ensure there are no expired items
            DateTime now = DateTime.Now;
            List<string> expiredKeys = cachedProcessors.Where(i => i.Value.ExpiryDate < now).Select(i => i.Key).ToList();
            foreach (string key in expiredKeys)
                cachedProcessors.Remove(key);
        }

        /// <summary>
        /// Converts class to an xml string. 
        /// Only contains the essential data need to recreate the processor using ReadXml, does not need every class member to do this.
        /// 03Apr13 XN 
        /// </summary>
        /// <returns>processor as XML (fragment) string</returns>
        public string WriteXml()
        {
            DataContractSerializer serializer; 

            // Setup string as XML fragment
            XmlWriterSettings settings = new XmlWriterSettings();
            settings.Indent             = false;
            settings.OmitXmlDeclaration = true;
            settings.ConformanceLevel   = ConformanceLevel.Fragment;

            StringBuilder str = new StringBuilder();
            using (XmlWriter writer = XmlWriter.Create(str, settings))
            {
                // Write the regimen items to the string
                serializer = new DataContractSerializer(this.regimenItems.GetType()); 
                serializer.WriteObject(writer, this.regimenItems);
                
                // Write deleted items to the string
                serializer = new DataContractSerializer(this.deletedItems.GetType());
                serializer.WriteObject(writer, this.deletedItems);

                // Write the regimen to the string
                this.Regimens.WriteXml(writer);

                writer.Close();
            }
            return str.ToString();
        }

        /// <summary>
        /// Read xml string to recreate the processor 
        /// Assuems xml string is created by WriteXml.
        /// Note the processor will read information from the DB (read-only info) as the xml does not contain all the data
        /// 03Apr13 XN 
        /// </summary>
        /// <returns>processor as XML (fragment) string</returns>
        public void ReadXml(string xml)
        {
            DataContractSerializer serializer; 

            // Setup string as XML fragment
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.ConformanceLevel = ConformanceLevel.Fragment;

            using (XmlReader reader = XmlReader.Create(new StringReader(xml), settings))
            {
                // Read regimen items from string
                serializer = new DataContractSerializer(typeof(List<PNRegimenItem>)); 
                List<PNRegimenItem> regimenItems = (List<PNRegimenItem>)serializer.ReadObject(reader);
                
                // Read deleted items from string
                serializer = new DataContractSerializer(typeof(List<string>));
                List<string> deletedItems= (List<string>)serializer.ReadObject(reader);

                // read regimen from the string
                PNRegimen regimens = new PNRegimen();
                regimens.ReadXml(reader);

                // Reinit with regimen data
                this.Initalise(regimens, regimenItems);

                // Set deleted items
                this.deletedItems = deletedItems;
            }
        }

        /// <summary>Replaces one product, with another, maintaining an ingredient value</summary>
        /// <param name="originalPNCode">Original product to rep1lace</param>
        /// <param name="newPNCode">New product</param>
        /// <param name="ingDBName">Ingredient value to maintain</param>
        public void Replace(string originalPNCode, string newPNCode, string ingDBName)
        {
            PNProduct     products     = PNProduct.GetInstance();
            PNRegimenItem originalItem = this.RegimenItems.FindByPNCode(originalPNCode);

            double ingOriginalValue = products.FindByPNCode(originalPNCode).CalculateIngredientValue(ingDBName, originalItem.VolumneInml);
            double newProductVolume = products.FindByPNCode(newPNCode).CalculateVolume(ingDBName, ingOriginalValue).Value;

            this.RemoveItem(originalPNCode);
            this.UpdateItem(newPNCode, newProductVolume);
        }

        public double? CalculateGlucosePercenrtage(PNProductType productType)
        {
            double totalGlucose    = this.RegimenItems.FindByAqueousOrLipid(productType).CalculateTotal(PNIngDBNames.Glucose);
            double totalVolumeInml = this.RegimenItems.FindByAqueousOrLipid(productType).CalculateTotal(PNIngDBNames.Volume );

            return (totalVolumeInml > 0.0) ? totalGlucose * 100.0 / totalVolumeInml : (double?)null;
        }

        /// <summary>
        /// Caclulates the glucose concentration of the regimen.
        ///     {total glucose} / {total volume} as percentage
        /// Will caclulate total for aqueous only products, and if combined for the combined regimen
        /// Returns string as (or N/A if no regimen defined)
        ///     {aqueous glucose con}% aqueous part only, {{total glucose con}% or more when combined}
        /// </summary>
        /// <param name="isCombined">If regimen is combined</param>
        public string CalculateGlucosePercenrtageAsString()
        {
            StringBuilder str = new StringBuilder();
            double? glucosePercentage;

            // Calculate aqueoous part
            glucosePercentage = CalculateGlucosePercenrtage(PNProductType.Aqueous);
            if (glucosePercentage.HasValue)
                str.AppendFormat("{0}% aqueous part only", glucosePercentage.Value.ToPNString());

            // Caculate combined part (if requested)
            glucosePercentage = CalculateGlucosePercenrtage(PNProductType.Combined);
            if (this.Regimen.IsCombined && glucosePercentage.HasValue)
                str.AppendFormat(",  {0}% or more when combined", glucosePercentage.Value.ToPNString());

            if (str.Length == 0)
                str.Append("N/A");

            return str.ToString();
        }

        /// <summary>
        /// Caculate number of kcal due to fat in the regimen
        ///     total fat * kcalPerGramOfFat
        /// kcalPerGramOfFat - WConfiguration constant
        /// </summary>
        public double CalculatekcalFat()
        {
            return this.RegimenItems.CalculateTotal(PNIngDBNames.Fat) * this.kcalPerGramFat;
        }

        /// <summary>
        /// Caculate number of kcal due to glucose in the regimen
        ///     total glucose * kcalPerGramOfGlucose
        /// kcalPerGramOfGlucose - WConfiguration constant
        /// </summary>
        public double CalculatekcalCHO()
        {
            return this.RegimenItems.CalculateTotal(PNIngDBNames.Glucose) * this.kcalPerGramGlucose;
        }

        /// <summary>
        /// Calculate the calorie ratio fat to glucose calculated as 
        /// Glucose part
        ///              calories due to glucose
        /// ---------------------------------------------   * 100
        /// calories due to glucose + calories due to fat    
        /// 
        /// Fat part
        ///                calories due to fat
        /// ---------------------------------------------   * 100
        /// calories due to glucose + calories due to fat    
        /// 
        /// Returns result as string
        ///     {fat part}:{glucose part}  percent kcals fat:glucose
        /// </summary>
        public string CalculateCalorieRatio()
        {
            double kcalFat = CalculatekcalFat();
            double kcalCHO = CalculatekcalCHO();

            if (kcalFat.IsZero() && kcalCHO.IsZero())
                return "0:0 percent kcals fat:glucose";
            else if (kcalFat.IsZero())
                return "0:100 percent kcals fat:glucose";
            else if (kcalCHO.IsZero())
                return "100:0 percent kcals fat:glucose";
            else
            {
                int CHOPercentage = (int)((kcalCHO * 100.0) / (kcalCHO + kcalFat));

                int fatPart     = (100 - CHOPercentage);
                int glucosePart = CHOPercentage;

                return string.Format("{0}:{1} percent kcals fat:glucose", fatPart, glucosePart);
            }
        }

        /// <summary>Multiplies regimen by scaling factor (where 100% is no change)</summary>
        //public void ScaleBy(int percentageFactor) TFS31013 2Apr12 XN Allow scaling by double value (rather than just integer)
        public void ScaleBy(double percentageFactor)
        {
            double scale = percentageFactor / 100.0;
            foreach (PNRegimenItem item in this.RegimenItems.ToList())  // Use too list as scaling might delete items if goes below zero
                this.UpdateItem(item.PNCode, (item.VolumneInml * scale));
        }

        /// <summary>
        /// Use water content            g H2O/ml
        /// and osmolarity               mosm/ml
        /// Sum volume of all products   ml
        /// Sum osmolarity "    "        mosm/ml * ml
        /// Sum water content " "        g H2O/ml * ml
        /// Osmolarity is equal to
        ///     Sum(mosm/ml * ml) / Sum(ml)
        /// Osmolality is equal to
        /// Sum(mosm/ml * ml) / Sum(ml)
        /// ----------------------------
        /// Sum(g H2O/ml * ml) / Sum(ml)
        /// 
        /// This algebraically equal to
        /// Sum(mosm/ml * ml)
        /// ------------------
        /// Sum(g H2O/ml * ml)
        /// and is measured in units of mOsmol per gram of water, mOsm/gH2O
        /// This procedure reports in units of mOsmol per kg of water, mOsm/kgH2O
        /// </summary>
        /// <param name="PNCodesMissed">PNCodes of regimen items missed as have no mOsmperml, or gH2Operml</param>
        /// <param name="PNCodesInvalidVol">PNCodes of regimen items missed as item volume is below zero!</param>
        /// <returns></returns>
        public double CalculateOsmolality (out List<string> PNCodesMissed, out List<string> PNCodesInvalidVol)
        {
            double sumOsmolarity   = 0.0;
            double sumWaterContent = 0.0;

            PNCodesMissed     = new List<string>();
            PNCodesInvalidVol = new List<string>();

            foreach (PNRegimenItem item in this.RegimenItems)
            {
                PNProductRow product = item.GetProduct();
                if (item.VolumneInml < 0)
                    PNCodesInvalidVol.Add(item.PNCode);
                else if ((product.mOsmperml > 0.0 || (product.mOsmperml.IsZero() && item.PNCode == "WATI000")) && product.gH2Operml > 0.0)
                {
                    sumOsmolarity   += product.mOsmperml * item.VolumneInml;
                    sumWaterContent += product.gH2Operml * item.VolumneInml;
                }
                else
                    PNCodesMissed.Add(item.PNCode);
            }

            return (sumWaterContent > 0.0) ? 1000.0 * (sumOsmolarity / sumWaterContent) : 0.0;
        }

        /// <summary>
        /// If ...
        /// Calcium(mmol/kg) + Phosphate (mmol/kg)
        /// --------------------------------------
        /// Volume(ml/kg) / 150
        /// ... exceeds 2.3 then precipitation is likely
        /// 
        /// This procedure notes that the weight (kg) cancels & plays no part in the overall calculation. 
        /// The result is divided by 2.3 so that if result>1 then precipitation is likely.
        /// Note also that a combined regimen is treated as if separate aqueous & fat bags are being prepared. 
        /// This is because precipitation can still occur during preparation.
        /// Value returned=0 if volume is zero, or Ca or PO4 are absent
        /// </summary>
        public double CheckCaPO4Solubility()
        {
            IEnumerable<PNRegimenItem> aqueousOnly = this.regimenItems.FindByAqueousOrLipid(PNProductType.Aqueous).ToList();

            double totalVolume      = aqueousOnly.CalculateTotal(PNIngDBNames.Volume);
            double totalCalcium     = aqueousOnly.CalculateTotal(PNIngDBNames.Calcium);
            double totalInorganicPO4= aqueousOnly.CalculateTotal(PNIngDBNames.InorganicPhosphate);

            double result = 0.0;
            if (totalVolume > 0.0 && totalCalcium > 0.0 && totalInorganicPO4 > 0.0)
                result = (totalCalcium + totalInorganicPO4) / (totalVolume / 150) / 2.3;

            return result;
        }

        public void AutoPopulateRegimen(out Dictionary<PNProductRow,double> doseReducedForMax, out Dictionary<PNProductRow,double> doseReducedForMaxPerKg, bool removeNegativeProducts)
        {
            PNProduct products = PNProduct.GetInstance();
            double originalVolume;

            doseReducedForMax      = new Dictionary<PNProductRow,double>();
            doseReducedForMaxPerKg = new Dictionary<PNProductRow,double>();

            // Remove exiting items
            foreach (PNRegimenItem items in this.RegimenItems.ToList())
                this.RemoveItem(items.PNCode);

            AutoPopulateItem(PNIngCode.N,    PNIngDBNames.Nitrogen, Regimen.GetIngredient(PNIngDBNames.Nitrogen),        0.0, doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.Vaqu, PNIngDBNames.Volume,   Regimen.GetIngredient(PNIngDBNames.AqueousVitamins), 0.0, doseReducedForMax, doseReducedForMaxPerKg);

            double? volume = this.Regimen.GetIngredient(PNIngDBNames.LipidVitamins);
            if (volume.HasValue)
            {
		        // If 'Solivito in Vitlipid' is used for the aqueous vitamins then check
		        // if less Vitlipid is needed here, using Vitamin K as marker for product
                PNProductRow vlipProduct = products.FindByPNCode(this.ingredientToPNCode[PNIngCode.Vlip]);
                originalVolume = volume.Value;
                if (vlipProduct.LimitToMaxmlTotal(ref volume))
                    doseReducedForMax.Add(vlipProduct, originalVolume);
                if (vlipProduct.LimitToMaxmlPerKg(ref volume, Prescription.DosingWeightInkg))
                    doseReducedForMaxPerKg.Add(vlipProduct, originalVolume);

                // Then convert value to equivalent quantity of vitamin E
                double? volumeVitE = vlipProduct.CalculateIngredientValue(PNIngDBNames.VitaminE, volume.Value);

                // Now convert back from VitE to equivalent mls of PrdVlip
                if (volumeVitE.HasValue)
                {
                    volumeVitE -= this.RegimenItems.CalculateTotal(PNIngDBNames.VitaminE);
                    volume     =  vlipProduct.CalculateVolume(PNIngDBNames.VitaminE, volumeVitE.Value);
                    if (volume.HasValue)
                        this.UpdateItem(vlipProduct.PNCode, volume.Value);
                }
            }

            AutoPopulateItem(PNIngCode.Fat, PNIngDBNames.Fat,              Regimen.GetIngredient(PNIngDBNames.Fat),             regimenItems.CalculateTotal(PNIngDBNames.Fat),      doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.Zn,  PNIngDBNames.Zinc,             Regimen.GetIngredient(PNIngDBNames.Zinc),            regimenItems.CalculateTotal(PNIngDBNames.Zinc),     doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.Ca,  PNIngDBNames.Calcium,          Regimen.GetIngredient(PNIngDBNames.Calcium),         regimenItems.CalculateTotal(PNIngDBNames.Calcium),  doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.Mg,  PNIngDBNames.Magnesium,        Regimen.GetIngredient(PNIngDBNames.Magnesium),       regimenItems.CalculateTotal(PNIngDBNames.Magnesium),doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.Se,  PNIngDBNames.Selenium,         Regimen.GetIngredient(PNIngDBNames.Selenium),        regimenItems.CalculateTotal(PNIngDBNames.Selenium), doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.Cu,  PNIngDBNames.Copper,           Regimen.GetIngredient(PNIngDBNames.Copper),          regimenItems.CalculateTotal(PNIngDBNames.Copper),   doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.Fe,  PNIngDBNames.Iron,             Regimen.GetIngredient(PNIngDBNames.Iron),            regimenItems.CalculateTotal(PNIngDBNames.Iron),     doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.PO4, PNIngDBNames.Phosphate,        Regimen.GetIngredient(PNIngDBNames.Phosphate),       regimenItems.CalculateTotal(PNIngDBNames.Phosphate),doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.Na,  PNIngDBNames.Sodium,           Regimen.GetIngredient(PNIngDBNames.Sodium),          regimenItems.CalculateTotal(PNIngDBNames.Sodium),   doseReducedForMax, doseReducedForMaxPerKg);
            AutoPopulateItem(PNIngCode.K,   PNIngDBNames.Potassium,        Regimen.GetIngredient(PNIngDBNames.Potassium),       regimenItems.CalculateTotal(PNIngDBNames.Potassium),doseReducedForMax, doseReducedForMaxPerKg);

            // Allow universal diluent to be WFI or any glucose concentration
            double totalGlucoseToAdd = (this.Regimen.GetIngredient(PNIngDBNames.Glucose) ?? 0.0) - this.RegimenItems.CalculateTotal(PNIngDBNames.Glucose);
            double totalVolumeToAdd  = (this.Regimen.GetIngredient(PNIngDBNames.Volume ) ?? 0.0) - this.RegimenItems.CalculateTotal(PNIngDBNames.Volume );

            PNProductRow glucoseProduct = products.FindByPNCode(this.ingredientToPNCode[PNIngCode.Gluc]);
            PNProductRow diuentProduct  = products.FindByPNCode(this.ingredientToPNCode[PNIngCode.Dil ]);
            double proudctGlConcGl  =  glucoseProduct.GetIngredient(PNIngDBNames.Glucose).Value / glucoseProduct.ContainerVolumeInml;
            double proudctDilConcGl =  diuentProduct.GetIngredient (PNIngDBNames.Glucose).Value / diuentProduct.ContainerVolumeInml;

            // Set volume required of main glucose product
            double? glucoseVolume = (proudctDilConcGl * totalVolumeToAdd - totalGlucoseToAdd) / (proudctDilConcGl - proudctGlConcGl);
            originalVolume = glucoseVolume.Value;
            if (glucoseProduct.LimitToMaxmlTotal(ref glucoseVolume))
                doseReducedForMax.Add(glucoseProduct, originalVolume);
            if (glucoseProduct.LimitToMaxmlPerKg(ref glucoseVolume, Prescription.DosingWeightInkg))
                doseReducedForMaxPerKg.Add(glucoseProduct, glucoseVolume.Value);
            this.UpdateItem(glucoseProduct.PNCode, originalVolume);

            // Set volume required of main diluent
            double? diluentVolume = totalVolumeToAdd - glucoseVolume;
            originalVolume = diluentVolume.Value;
            if (diuentProduct.LimitToMaxmlTotal(ref diluentVolume))
                doseReducedForMax.Add(diuentProduct, originalVolume);
            if (diuentProduct.LimitToMaxmlPerKg(ref diluentVolume, Prescription.DosingWeightInkg))
                doseReducedForMaxPerKg.Add(diuentProduct, diluentVolume.Value);
            this.UpdateItem(diuentProduct.PNCode, originalVolume);

            // Scan all volumes & remove tiny ones
            this.regimenItems.RemoveAll(i => Math.Abs(i.VolumneInml) > 0.0 && Math.Abs(i.VolumneInml) < 0.01);
            this.regimenItems.ForEach(i => i.VolumneInml = i.VolumneInml.To3SigFigish());

            if (removeNegativeProducts)
                this.regimenItems.RemoveAll(i => i.VolumneInml < 0.0);
        }

        public void AutoPopulateItem(string ingCode, string ingDBName, double? requiredIngValue, double? existingIngValue, Dictionary<PNProductRow,double> doseReducedForMax, Dictionary<PNProductRow,double> doseReducedForMaxPerKg)
        {
            //if (requiredIngValue.HasValue)    TFS30845 30Mar12 XN fix problem with crash if ingreident rule is not supported.
            if (requiredIngValue.HasValue && ingredientToPNCode.ContainsKey(ingCode))
            {
                string  PNCode       = ingredientToPNCode[ingCode];
                PNProductRow product = PNProduct.GetInstance().FindByPNCode(PNCode);
                double? volume       = product.CalculateVolume(ingDBName, requiredIngValue.Value - existingIngValue.Value);

                if (volume.HasValue)
                {
                    double originalVolume = volume.Value;

                    if (product.LimitToMaxmlTotal(ref volume))
                        doseReducedForMax.Add(product, originalVolume);
                    if (product.LimitToMaxmlPerKg(ref volume, Prescription.DosingWeightInkg))
                        doseReducedForMaxPerKg.Add(product, originalVolume);

                    this.UpdateItem(PNCode, volume.Value);
                }
            }
        }
    }
}